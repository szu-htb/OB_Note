**定时器就是计数器,定时器就是计数器,定时器就是计数器**

是从0开始计数的!!!
# **AP**I
## 函数
```c
//定时器启动
HAL_TIM_Base_Start();
//启动+中断
HAL_TIM_Base_Start_IT()
```
## 宏定义
```c
__HAL_TIM_GET_COUNTER();
__HAL_TIM_SET_COUNTER();

```

> 一个获取一个设置,其实把后面的**COUNTER**改成**AUTORELOAD**就是修改重装载寄存器的值

# 时钟树与时钟源
这里不作过多介绍,随着使用会慢慢加深理解!
# 定时
通过不同模式的巧妙组合,可以实现如下功能:
- **捕获**脉冲宽度
- **输出**PWM波形
- 计算**PWM**占空比
- 编码器**计数**
## 定时器的种类
以**STM32F103**为例子

| 高级定时器 | 通用定时器 | 基本定时器 |
| ----- | ----- | ----- |
| TIM1  | TIM2  | TIM6  |
| TIM8  | TIM3  | TIM7  |
|       | TIM4  |       |
|       | TIM5  |       |

高级定时器多了,**刹车信号输入**,**死区时间互补输出**等工业电机的功能
## 基本定时器
我们是如何定时的?原理:只要我们有个恒定频率的方波信号,再加上寄存器就能实现定时
> 再加上我们知道方波频率 → ~~计数~~**计时** ; **方波**从哪里来?这个时候就知道**时钟树**的作用是什么

但是**计数器**长度为**16bit**,很遗憾按照我们所想的方法,只能计65536个数了,只能计时0.0009s,显然有点不够了

所以聪明的人已经想到要用一个**嵌套**时的结构,再套一个计数器上去,这样我们就可以计65535^2次了

这里引入**预分频器,**
![image.png](https://murmur-1329567155.cos.ap-guangzhou.myqcloud.com/picture/20250324131715309.png)

但是单纯计数用途不广,我们得有个结构来提醒我们当达到了计数次数时
这里又要引入一个**自动重装载寄存器**,不断判断自己的值是否与计数器的值一致(也是我们需要去配置的一个寄存器),他的作用是:
- 值与计数器的相同时,将计数器置零
- 设置后,可以触发**更新中断**

## 实战
ennn,不能在创建工程这个操作浪费时间,所以不作太多记录
### 中断回调函数
在`Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim.c`中可以找到`…PeriodElapsedCallback()` ,进行重写
> ***同时记得判断一下触发源是什么***
## 拓展知识
其实工作在一线的是**影子寄存器**,其**作用**:就是确保设置的新值是在**下个计数周期**才生效,不影响当前工作周期
如何设置??
再**Cubemx**中,将`auto-reload preload` 改为`Enable`即可